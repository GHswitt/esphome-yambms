# Updated : 2025.07.26
# Version : 1.1.1
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

substitutions:
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Alpha value for the exponential moving average filter.
  required_charge_current_alpha: "0.25"
  # Filter delay in minutes. The charge current will not be updated more often than this value.
  # This is to prevent the charge current from fluctuating too much.
  required_charge_current_filter_delay: "3"

switch:
  - platform: template
    name: ${name} ${yambms_name} Automatic EOC Current
    id: ${yambms_id}_switch_auto_eoc
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config
  - platform: template
    name: ${name} ${yambms_name} Automatic EOC Float support
    id: ${yambms_id}_switch_auto_eoc_float
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

number:
  - platform: template
    name: ${name} ${yambms_name} Auto EOC Target Hour
    id: ${yambms_id}_auto_eoc_target_hour
    step: 1
    min_value: 12
    max_value: 23
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 18
    unit_of_measurement: h
    icon: mdi:clock-digital
    optimistic: true
    entity_category: config

  - platform: template
    name: ${name} ${yambms_name} Auto EOC Target Minute
    id: ${yambms_id}_auto_eoc_target_min
    step: 15
    min_value: 0
    max_value: 45
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 0
    unit_of_measurement: m
    icon: mdi:clock-digital
    optimistic: true
    entity_category: config

  - platform: template
    name: "${name} ${yambms_name} Auto EOC Correction"
    id: "${yambms_id}_auto_eoc_correction"
    step: 1
    min_value: -20
    max_value: 20
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 0
    unit_of_measurement: '%'
    icon: mdi:arrow-oscillating
    optimistic: true
    entity_category: config

  - platform: template
    name: "${name} ${yambms_name} Auto EOC Float Correction"
    id: "${yambms_id}_auto_eoc_correction_float"
    step: 1
    min_value: 0
    max_value: 30
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 0
    unit_of_measurement: '%'
    icon: mdi:arrow-oscillating
    optimistic: true
    entity_category: config

  - platform: template
    name: "${name} ${yambms_name} Auto EOC Capacity Modifier"
    id: "${yambms_id}_auto_eoc_modifier"
    step: 1
    min_value: -10
    max_value: 0
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: -2
    unit_of_measurement: '%'
    icon: mdi:battery-arrow-down
    optimistic: true
    entity_category: config

  - platform: template
    name: "${name} ${yambms_name} Auto EOC Increase Stop Hours"
    id: "${yambms_id}_auto_eoc_stop_hours"
    step: 0.5
    min_value: 0
    max_value: 4
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 1
    unit_of_measurement: 'h'
    icon: mdi:timer-stop
    optimistic: true
    entity_category: config

  - platform: template
    name: "${name} ${yambms_name} Auto EOC Increase Stop SoC"
    id: "${yambms_id}_auto_eoc_stop_soc"
    step: 1
    min_value: 50
    max_value: 100
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 97
    unit_of_measurement: '%'
    icon: mdi:battery-charging-80
    optimistic: true
    entity_category: config

text_sensor:
  # +--------------------------------------+
  # | Auto EOC Status                     |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Auto EOC Status"
    id: ${yambms_id}_auto_eoc_status
    update_interval: never
    icon: mdi:information-outline
    entity_category: diagnostic

sensor:
  # +--------------------------------------+
  # | Auto EOC Charging                    |
  # +--------------------------------------+
    # Filter charging current to smooth out fluctuations
    # The value will be updated every 3 minutes
  - platform: copy
    source_id: ${yambms_id}_auto_eoc_charging_current
    name: ${name} ${yambms_name} Auto EOC Current
    id: "${yambms_id}_auto_eoc_charging_current_filtered"
    unit_of_measurement: A
    device_class: current
    filters:
      - exponential_moving_average:
          alpha: ${required_charge_current_alpha}
          send_every: ${required_charge_current_filter_delay}
          send_first_at: 1
      - round: 0

  - platform: template
    name: ${name} ${yambms_name} Auto EOC Required Current
    id: ${yambms_id}_auto_eoc_charging_current
    update_interval: 60s
    unit_of_measurement: A
    device_class: current
    #internal: true
    filters:    
      - round: 0
    lambda: |-
      // Check if enabled
      if (!id(${yambms_id}_switch_auto_eoc).state || 
          !id(${yambms_id}_battery_capacity).has_state() ||
          !id(${yambms_id}_capacity_remaining_ah).has_state() ||
          !id(${yambms_id}_max_charge_current).has_state()) {
        // Auto EOC Charging disabled
        //ESP_LOGI("auto_eoc", "Auto EOC Charging is disabled or battery capacity is not available");
        id(${yambms_id}_auto_eoc) = 0;
        id(${yambms_id}_auto_eoc_status).publish_state("Stop: Disabled");
        return 0;
      }

      // Check if Float is active
      const bool float_active = id(${yambms_id}_charging_instruction).state == "Float";
      if (!id(${yambms_id}_switch_auto_eoc_float).state && float_active) {
        id(${yambms_id}_auto_eoc) = 0;
        id(${yambms_id}_auto_eoc_status).publish_state("Stop: Float");
        return 0;
      }

      // Check if current time is valid
      const auto current_time = id(my_time).now();
      if (!current_time.is_valid()) {
        ESP_LOGW("auto_eoc", "Time not valid");
        id(${yambms_id}_auto_eoc) = 0;
        id(${yambms_id}_auto_eoc_status).publish_state("Stop: Time not valid");
        return 0;
      }

      // Get target time
      const int target_hour = id(${yambms_id}_auto_eoc_target_hour).state;
      const int target_minute = id(${yambms_id}_auto_eoc_target_min).state;

      // Create target timestamp
      auto target_time = current_time;
      target_time.hour = target_hour;
      target_time.minute = target_minute;
      target_time.recalc_timestamp_local();

      // Calculate hours left until target time
      const float hours_left = (target_time.timestamp - current_time.timestamp) / 3600.0;

      if (hours_left <= 0) {
        //ESP_LOGI("auto_eoc", "Target time has already passed");
        id(${yambms_id}_auto_eoc) = 0;
        id(${yambms_id}_auto_eoc_status).publish_state("Stop: Target time passed");
        return 0;
      }

      // Check if we stop increasing the charge current
      bool stop_increasing = false;
      if (id(${yambms_id}_battery_soc).has_state() && (id(${yambms_id}_battery_soc).state >= id(${yambms_id}_auto_eoc_stop_soc).state)) {
        ESP_LOGI("auto_eoc", "Stopping charge current increase, SoC is above threshold");
        stop_increasing = true;
      } else if (hours_left <= id(${yambms_id}_auto_eoc_stop_hours).state) {
        ESP_LOGI("auto_eoc", "Stopping charge current increase, hours left is below threshold");
        stop_increasing = true;
      }

      // Get battery capacity
      auto battery_capacity = id(${yambms_id}_battery_capacity).state;

      // Apply negative capacity modifier
      battery_capacity += (battery_capacity * (id(${yambms_id}_auto_eoc_modifier).state / 100.0));
     
      // Calculate missing capacity
      auto capacity_required = battery_capacity - id(${yambms_id}_capacity_remaining_ah).state;
      if (capacity_required < 0) {
        capacity_required = 0;
      }

      // Get active charge current, this will be our maximum charge current
      float charge_current = id(${yambms_id}_max_charge_current).state + id(${yambms_id}_auto_ccl);

      // Calculate required charge current
      float required_charge_current = capacity_required / hours_left;

      // Apply charge current correction factor
      float correction_factor = (id(${yambms_id}_auto_eoc_correction).state / 100.0) + 1.0;
      if (float_active) {
        // If Float is active, apply additional float correction factor
        correction_factor += (id(${yambms_id}_auto_eoc_correction_float).state / 100.0);
      }
      required_charge_current *= correction_factor;

      // If the required charge current higher than the maximum charge current, return 0 to indicate
      // that there is no solution
      float return_value = 0;
      if (required_charge_current >= charge_current) {
        //ESP_LOGI("auto_eoc", "Required charge current is higher than maximum charge current");
        required_charge_current = 0;
        id(${yambms_id}_auto_eoc_status).publish_state("Stop: Current above limit");
      } else {
        // The value is valid, return it
        return_value = required_charge_current;

        // Check if filtered charging current is available
        if (id(${yambms_id}_auto_eoc_charging_current_filtered).has_state()) {
          const float filtered_charge_current = id(${yambms_id}_auto_eoc_charging_current_filtered).state;

          // Check if current is increasing and we should stop
          if (stop_increasing && (required_charge_current > filtered_charge_current)) {
            // Return previous filtered charge current
            return_value = filtered_charge_current;
            id(${yambms_id}_auto_eoc_status).publish_state("Run: Current increase stopped");
          } else {
            // Update status to running
            id(${yambms_id}_auto_eoc_status).publish_state("Run");
          }

          // Use filtered charge current for calculations
          required_charge_current = filtered_charge_current;
        }
      }

      // Limit required charge current to maximum charge current
      if (required_charge_current && (required_charge_current < charge_current)) {
        // Calculate negative difference to charge current
        id(${yambms_id}_auto_eoc) = round(required_charge_current - charge_current);
      } else {
        id(${yambms_id}_auto_eoc) = 0;
      }

      return return_value;
